/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include <stm32f4xx.h>
#include <stdint.h>
#include "FreeRTOS.h"
#include <stdio.h>
#include "task.h"
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "PLLDriver.h"
#include "SEGGER_SYSVIEW.h"
#include "ExtiDriver.h"

#define STACK_SIZE 200
#define CLOCK_MHZ 100

void vTaskOne(void *pvParameters);
void vTaskTwo(void *pvParameters);
void configPeripherals(void);
void taskCreation(void);
extern void SEGGER_UART_init(uint32_t);
extern void vInitPrioGroupValue(void);

GPIO_Handler_t ledUsuario = { 0 };
GPIO_Handler_t rx2pin = { 0 };
GPIO_Handler_t tx2pin = { 0 };
GPIO_Handler_t userB = { 0 };
EXTI_Config_t userBE = {0};

TaskHandle_t HandleTask1 = NULL;
TaskHandle_t HandleTask2 = NULL;
//Handler para el control de la terminal
USART_Handler_t handlerTerminal = { 0 };

/*DefiniciÃ³n de variables del sistema*/

uint8_t globalCounter = 0;
uint32_t SystemCoreClock = CLOCK_MHZ * 1E6;
uint8_t rxData = 0;
char msg[8] = { 0 };

int main(void) {
	configPeripherals();
	taskCreation();
	//Start the created task running.
	vTaskStartScheduler();

	/* Loop forever */
	while (1) {
		/* SI llegamos es que algo salio mal... */
	}
}

void configPeripherals(void) {

	//Activacion cooprocesador matematico(importante para esta tarea)
	SCB->CPACR |= (0xF << 20);

	//Enale the CYCNT counter
	DWT->CTRL |= (1 << 0);

	SEGGER_UART_init(500000);

	SEGGER_SYSVIEW_Conf();

	vInitPrioGroupValue();

	configPLL(CLOCK_MHZ);

	ledUsuario.pGPIOx = GPIOA;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_OUT;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinNumber = PIN_5;
	GPIO_Config(&ledUsuario);

	userB.pGPIOx = GPIOC;
	userB.GPIO_PinConfig_t.GPIO_PinNumber = PIN_13;
	userB.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_IN;

	userBE.edgeType = EXTERNAL_INTERRUPT_FALLING_EDGE;
	userBE.pGPIOHandler = &userB;
	extInt_Config(&userBE);
}

void taskCreation(void) {
	BaseType_t xReturned;


	xReturned = xTaskCreate(vTaskOne, /* Function that implements the task. */
	"Task-1", /* Text name for the task. */
	512, /* Stack size in words, not bytes. */
	NULL, /* Parameter passed into the task. */
	2,/* Priority at which the task is created. */
	&HandleTask1); /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

	xReturned = xTaskCreate(vTaskTwo, /* Function that implements the task. */
	"Task-2", /* Text name for the task. */
	512, /* Stack size in words, not bytes. */
	NULL, /* Parameter passed into the task. */
	2,/* Priority at which the task is created. */
	&HandleTask2); /* Used to pass out the created task's handle. */

	configASSERT(xReturned == pdPASS);

}

/* Fncin que gobierna la tarea 1 */
void vTaskOne(void *pvParameters) {
	BaseType_t notifyState = { 0 };
	uint8_t change_sate = 0;
	while (1) {

		notifyState = xTaskNotifyWait(0, 0, NULL, pdMS_TO_TICKS(250));
		if (notifyState == pdTRUE) {
			change_sate ^= 0b1;
		}
		if (change_sate) {
			printf("toggle\n");
			GPIOxTooglePin(&ledUsuario);
		} else {
			GPIO_WritePin(&ledUsuario, RESET);
		}
	}
}

/* Fncin que gobierna la tarea 2 */
void vTaskTwo(void *pvParameters) {

	uint8_t button_state = 0;
	uint8_t prev_button_state  = 0;

	while (1) {

		button_state = GPIO_ReadPin(&userB);

		if(button_state){
			if(!prev_button_state){
				xTaskNotify(HandleTask1,0,0);
			}
		}

		prev_button_state = button_state;

		vTaskDelay(pdMS_TO_TICKS(10));

	}
}

void USART2Rx_Callback(void) {
	rxData = getRxData();
	writeChar(&handlerTerminal, rxData);
}

