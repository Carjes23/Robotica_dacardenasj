/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
#include "GPIOxDriver.h"
#include "BasicTimer.h"
#include "USARTxDriver.h"
#include "PLLDriver.h"
#include <stdint.h>
#include <stdio.h>
#include "AdcDriver.h"
#include "PLLDriver.h"
#include "string.h"
#include "PwmDriver.h"
//pc7

#include "ExtiDriver.h"

void configPeripherals(void);
void parseCommands(char *ptrBufferReception);

//Handler para el control de la terminal
USART_Handler_t handlerTerminal = { 0 };
//Para la recepcion de datos por la terminal
uint8_t rxData = 0;
uint16_t adcLastData = 0;

uint16_t counterReception = 0;

char bufferReception[64] = { 0 };
char cmd[64] = { 0 };
char bufferData[10] = { 0 };
unsigned int firstParameter = 256;
unsigned int secondParameter = 256;
unsigned int thirdParameter = 256;

bool stringComplete = 0;
bool printData = 0;
GPIO_Handler_t tx2pin = { 0 };	//Pin para configurar la trasmision del USART2
GPIO_Handler_t rx2pin = { 0 };	//Pin para configurar la recepcion del USART2

#define STACK_SIZE 200;

void vTaskOne(void *pvParameters);
void vTaskTwo(void *pvParameters);
void configPeripherals(void);
void taskCreation(void);

GPIO_Handler_t ledUsuario;
GPIO_Handler_t pwprueba;

/*Definici칩n de variables del sistema*/

uint8_t globalCounter = 0;
uint32_t SystemCoreClock = 16E6;

BasicTimer_Handler_t handlerTimer3;

PWM_Handler_t pwmadc = { 0 }; //Para configurar el PWM en el timer 3 para X
PWM_Handler_t pwmprueba = { 0 }; //Para configurar el PWM en el timer 3 para X

//Funcion para cuadrar el ADC
ADC_Config_t channnel_0 = { 0 };
GPIO_Handler_t PC7;
EXTI_Config_t PC7E;

int main(void) {

	configPeripherals();

	/* Loop forever */
	while (1) {
		/* SI llegamos es que algo salio mal... */
		/* El caracter '@' nos indica que es el final de la cadena*/
		if (rxData != '\0') {
			bufferReception[counterReception] = rxData;
			counterReception++;

			// If the incoming character is a newline, set a flag
			// so the main loop can do something about it
			if (rxData == '@') {
				stringComplete = 1;
				sprintf(bufferData, "\n");
				writeString(&handlerTerminal, bufferData);
				//Agrego esta linea para crear el string con el null al final
				bufferReception[counterReception] = '\0';
				counterReception = 0;
			}
			if (rxData == '\b') {
				counterReception--;
				counterReception--;
			}
			//Para que no vuelva entrar. Solo cambia debido a la interrupcion
			rxData = '\0';
		}

		//Hacemos un analisis de la cadena de datos obtenida
		if (stringComplete) {
			parseCommands(bufferReception);
			stringComplete = 0;
		}
	}
}

void configPeripherals(void) {

	//Activacion cooprocesador matematico(importante para esta tarea)
	SCB->CPACR |= (0xF << 20);

	configPLL(100);

	ledUsuario.pGPIOx = GPIOA;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_OUT;
	ledUsuario.GPIO_PinConfig_t.GPIO_PinNumber = PIN_5;
	GPIO_Config(&ledUsuario);

	handlerTimer3.ptrTIMx = TIM3; //El timer que se va a usar
	handlerTimer3.TIMx_Config.TIMx_interruptEnable = 1; //Se habilitan las interrupciones
	handlerTimer3.TIMx_Config.TIMx_mode = BTIMER_MODE_UP; //Se usara en modo ascendente
	handlerTimer3.TIMx_Config.TIMx_period = 2500; //Se define el periodo en este caso el led cambiara cada 250ms
	handlerTimer3.TIMx_Config.TIMx_speed = BTIMER_SPEED_100us; //Se define la "velocidad" que se usara

	BasicTimer_Config(&handlerTimer3); //Se carga la configuraci칩n.

	//Pines necesarios para el uso del USART2
	tx2pin.pGPIOx = GPIOA;
	tx2pin.GPIO_PinConfig_t.GPIO_PinNumber = PIN_2;
	tx2pin.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_ALTFN;
	tx2pin.GPIO_PinConfig_t.GPIO_PinPuPdControl = GPIO_PUPDR_PULLUP;
	tx2pin.GPIO_PinConfig_t.GPIO_PinSpeed = GPIO_OSPEED_FAST; //Se usa en velocidad rapida
	tx2pin.GPIO_PinConfig_t.GPIO_PinAltFunMode = 7;

	GPIO_Config(&tx2pin);

	rx2pin.pGPIOx = GPIOA;
	rx2pin.GPIO_PinConfig_t.GPIO_PinNumber = PIN_3;
	rx2pin.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_ALTFN;
	rx2pin.GPIO_PinConfig_t.GPIO_PinPuPdControl = GPIO_PUPDR_PULLUP;
	rx2pin.GPIO_PinConfig_t.GPIO_PinSpeed = GPIO_OSPEED_FAST;
	rx2pin.GPIO_PinConfig_t.GPIO_PinAltFunMode = 7;

	GPIO_Config(&rx2pin);

	handlerTerminal.ptrUSARTx = USART2;
	handlerTerminal.USART_Config.USART_baudrate = 115200;
	handlerTerminal.USART_Config.USART_datasize = USART_DATASIZE_8BIT;
	handlerTerminal.USART_Config.USART_mode = USART_MODE_RXTX;
	handlerTerminal.USART_Config.USART_parity = USART_PARITY_NONE;
	handlerTerminal.USART_Config.USART_stopbits = USART_STOPBIT_1;
	handlerTerminal.USART_Config.USART_RX_Int_Ena = ENABLE;

	USART_Config(&handlerTerminal);

	pwprueba.pGPIOx = GPIOA;
	pwprueba.GPIO_PinConfig_t.GPIO_PinNumber = PIN_0;
	pwprueba.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_ALTFN;
	pwprueba.GPIO_PinConfig_t.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	pwprueba.GPIO_PinConfig_t.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	pwprueba.GPIO_PinConfig_t.GPIO_PinSpeed = GPIO_OSPEED_FAST;
	pwprueba.GPIO_PinConfig_t.GPIO_PinAltFunMode = AF2;

	GPIO_Config(&pwprueba);

	pwprueba.pGPIOx = GPIOA;
	pwprueba.GPIO_PinConfig_t.GPIO_PinNumber = PIN_1;
	pwprueba.GPIO_PinConfig_t.GPIO_PinMode = GPIO_MODE_ALTFN;
	pwprueba.GPIO_PinConfig_t.GPIO_PinOPType = GPIO_OTYPE_PUSHPULL;
	pwprueba.GPIO_PinConfig_t.GPIO_PinPuPdControl = GPIO_PUPDR_NOTHING;
	pwprueba.GPIO_PinConfig_t.GPIO_PinSpeed = GPIO_OSPEED_FAST;
	pwprueba.GPIO_PinConfig_t.GPIO_PinAltFunMode = AF2;

	GPIO_Config(&pwprueba);

	pwmprueba.ptrTIMx = TIM5;
	pwmprueba.config.channel = PWM_CHANNEL_2;
	pwmprueba.config.duttyCicle = 100;
	pwmprueba.config.periodo = 500;
	pwmprueba.config.prescaler = 1000;
	pwmprueba.config.polarity = 1;

	pwm_Config(&pwmprueba);
	enableOutput(&pwmprueba);
	startPwmSignal(&pwmprueba);

	pwmadc.ptrTIMx = TIM5;
	pwmadc.config.channel = PWM_CHANNEL_1;
	pwmadc.config.duttyCicle = 100;
	pwmadc.config.periodo = 500;
	pwmadc.config.prescaler = 1000;
	pwmadc.config.polarity = 0;

	pwm_Config(&pwmadc);
	enableOutput(&pwmadc);
	startPwmSignal(&pwmadc);

	//COnfiugracion ADC se pones un samplig period de 56 ya que ~= 100 mhz / 56 ~= 1.78 Mhz que es m치s que suficiente
	uint8_t channels[1] = { ADC_CHANNEL_3 };
	channnel_0.channels = channels;
	channnel_0.dataAlignment = ADC_ALIGNMENT_RIGHT;
	channnel_0.numberOfChannels = 1;
	uint8_t samplingPeriod[1] = { 0 };
	samplingPeriod[0] = ADC_SAMPLING_PERIOD_56_CYCLES
	;
	channnel_0.samplingPeriod = samplingPeriod;
	channnel_0.resolution = ADC_RESOLUTION_12_BIT;
	channnel_0.externType = EXTEN_RISING_TIMER5_CC1;

	adc_Config(&channnel_0);
}

void parseCommands(char *ptrBufferReception) {

	/* Lee la cadena de caracteres a la que apunta el "ptrBufferReception
	 * y almacena en tres elementos diferentes: un string llamado "cmd",
	 * y dos integer llamados "firstParameter" y "secondParameter"
	 * De esta forma podemos introducir informacion al micro desde el puerto
	 */
	sscanf(ptrBufferReception, "%s %u %u %u", cmd, &firstParameter,
			&secondParameter, &thirdParameter);
	if (strcmp(cmd, "help") == 0) {
		writeString(&handlerTerminal, "Help Menu CMDs: \n");
		writeString(&handlerTerminal, "1)  Help -> Print this menu \n");

	} else if (strcmp(cmd, "s") == 0) {
		printData = firstParameter;
	}

	else if (strcmp(cmd, "p") == 0) {
		pwmUpdatePolarity(&pwmprueba, firstParameter);
	}

	else {
		// Se imprime el mensaje "Wrong CMD" si la escritura no corresponde a los CMD implementados
		writeString(&handlerTerminal, "Wrong CMD \n");
	}

}

//Calback del timer2 para el blinking
void BasicTimer3_Callback(void) {
	GPIOxTooglePin(&ledUsuario);
}

void USART2_IRQHandler(void) {
	if (USART2->SR & USART_SR_RXNE) {
		/* Limpiamos la bandera que indica que la interrupci칩n se ha generado */
		USART2->SR &= ~USART_SR_RXNE;
		//Auxiliar
		rxData = (uint8_t) USART2->DR;

	}

}

void adcComplete_Callback(void) {
	adcLastData = getADC();
	if (printData) {
		sprintf(bufferData, "%d\n", adcLastData);
		writeString(&handlerTerminal, bufferData);
	}
}

